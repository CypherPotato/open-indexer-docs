<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Sentinel Agents | AIVAX </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Sentinel Agents | AIVAX ">


        <link rel="icon" href="../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../public/docfx.min.css">
        <link rel="stylesheet" href="../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">
        
        <link href="https://cdn.jsdelivr.net/npm/remixicon@4.6.0/fonts/remixicon.css" rel="stylesheet">

        <meta name="docfx:navrel" content="../../toc.html">
        <meta name="docfx:tocrel" content="toc.html">

        <meta name="docfx:rel" content="../../">


        <meta name="docfx:docurl" content="https://github.com/CypherPotato/open-indexer-docs/blob/master/docs/en/sentinel.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
                
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((en)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../index.html">
                        <img id="logo" class="svg" src="../../assets/img/aivax.png" alt="AIVAX">
                        AIVAX
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/en/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="sentinel-agents">Sentinel Agents</h1>

<p>The Sentinel chat agents are models with optimized parameters for real-time chat conversation, with instructions that enhance the model's attention to specific tasks and allow for real-time internet research.</p>
<p>These models are constantly updated to utilize the latest technologies and resources available through generative AI, so the internal models used by the Sentinel models can be constantly updated.</p>
<p>Currently, the Sentinel models are available in three categories:</p>
<ul>
<li><strong>sentinel</strong>: highly intelligent. It uses the model's own deep thinking to complement the response.</li>
<li><strong>sentinel-mini</strong>: intelligent and capable for most complex chat tasks.</li>
<li><strong>sentinel-core</strong>: cost-optimized model, with lower conversation capability, but with Sentinel reasoning.</li>
</ul>
<p>Whenever a Sentinel model is to have its price changed, a notification is sent to all users who use the model and a notification is added to the notifications page.</p>
<p>These models should be used for conversation with the end-user and are not recommended for other tasks such as using functions, structured responses, etc.</p>
<h2 id="main-features">Main Features</h2>
<p>The differential of the Sentinel models are the resources provided &quot;out-of-the-box&quot; by them, including:</p>
<ul>
<li><strong>Optimized for chat</strong>: the Sentinel models have clear instructions that make the model adapt the conversation tone to that of the user, including humor and objective indicators.</li>
<li><strong>Reasoning</strong>: all Sentinel models have a customized deep thinking mechanism, optimized to reason based on their provided functions, including <a href="/docs/en/protocol-functions">protocol functions</a>, to provide a detailed response to the user.</li>
<li><strong>Internet research</strong>: the Sentinel models can naturally search the internet to complement their response in different scenarios, such as obtaining local news, weather data, or data on a specific topic or niche.</li>
<li><strong>Accessing links</strong>: the Sentinel models can access files and pages provided by the user. It can access HTML pages, various text files, even Word and PDF documents.</li>
<li><strong>Code execution</strong>: the Sentinel models can execute code to perform mathematical, financial, or other calculations to help the user with various tasks.</li>
<li><strong>Persistent memory</strong>: the Sentinel models can identify relevant facts to the user that should be persisted during multiple conversations, even after the current conversation is cleared or renewed.</li>
</ul>
<p>Additionally, all Sentinel models have a chain of execution of functions. For example, you can ask a Sentinel model to access the temperature of a city, convert it to JSON, and call an external URL with the response.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Important: the Sentinel context includes a detailed description of its behavior and functions and occupies approximately <strong>~1.300</strong> tokens that will be appended to all messages sent by the user.</p>
</div>
<h2 id="sentinel-router">Sentinel Router</h2>
<p>You can also use the <strong>sentinel-router</strong> routing model, which works as a router between the Sentinel models. A router automatically chooses which is the best model to solve the user's problem based on the complexity of their problem.</p>
<p>How does it work? A smaller model analyzes the context of the question and evaluates the degree of complexity the user is facing, and this model responds with an indicator of which model is best to answer that question. The router decides which is the best model per message and not per conversation.</p>
<p>A routing model can help reduce costs and maintain the quality of the conversation, using deep thinking resources only when necessary.</p>
<h2 id="sentinel-lambda">Sentinel Lambda</h2>
<p>The <strong>sentinel-lambda</strong> agent is optimized for use in <a href="/entities/functions">JSON functions</a>, being able to search the internet, execute code, and access links, which further improves the accuracy of intelligent function execution.</p>
<h2 id="sentinel-reasoning">Sentinel Reasoning</h2>
<p>The Sentinel's deep thinking mechanism is a plug-and-play reasoning engine that provides all the necessary context for the Sentinel model to respond to the user's question. During the thinking process, Sentinel calls functions, performs calculations, and executes code, aiming to provide an elaborate and precise response to the user, even when used with smaller and less intelligent models.</p>
<p>The pricing of Sentinel reasoning and tokens are separate: you will notice that when using the Sentinel model, you will see launches of routing, reasoning, and inference. This division is made to provide transparency about the use of Sentinel.</p>
<p>As the Sentinel reasoning is done in parts, you may have multiple instances of reasoning for a single question. This occurs because when Sentinel understands that it should call a function, it will think again when it has the function result. From this, it can call other functions in a chain until it has enough information to solve the user's problem.</p>
<p>Internally, two thinking models are used. A more complete one with CoT (chain-of-thought) is used, and a smaller one is used to summarize the thinking content. The summary reduces the amount of tokens sent to the larger model to reduce costs and maintain the same line of reasoning.</p>
<p>The <strong>sentinel</strong> agent thinks much more than the <strong>sentinel-mini</strong>, which leads the model to create a more precise response for complex situations. When using the Sentinel router, the more intelligent Sentinel agent is chosen only in highly complex and difficult situations.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/CypherPotato/open-indexer-docs/blob/master/docs/en/sentinel.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>