<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Server-side Functions | AIVAX </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Server-side Functions | AIVAX ">


        <link rel="icon" href="../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../public/docfx.min.css">
        <link rel="stylesheet" href="../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">
        
        <link href="https://cdn.jsdelivr.net/npm/remixicon@4.6.0/fonts/remixicon.css" rel="stylesheet">

        <meta name="docfx:navrel" content="../../toc.html">
        <meta name="docfx:tocrel" content="toc.html">

        <meta name="docfx:rel" content="../../">


        <meta name="docfx:docurl" content="https://github.com/CypherPotato/open-indexer-docs/blob/master/docs/en/protocol-functions.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
                
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((en)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../index.html">
                        <img id="logo" class="svg" src="../../assets/img/aivax.png" alt="AIVAX">
                        AIVAX
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/en/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="server-side-functions">Server-side Functions</h1>

<div class="IMPORTANT">
<h5>Important</h5>
<p>Protocol functions are no longer maintained and have been replaced by <a href="/docs/en/mcp">MCP functions</a>.</p>
</div>
<p>The AIVAX protocol functions, or <em>server-side functions</em>, are an implementation where the model's tool calls occur on the server side. Similar to MCP, but with native authentication support and optimized to work externally.</p>
<p>Protocol functions allow actions to be taken on the AIVAX server side, removing the need to implement the function on the client side and integrating with existing applications and services.</p>
<img src="/assets/diagrams/protocol-functions-1.drawio.svg">
<p>These functions expect a <strong>callback</strong> via a URL, and when the model decides to call the function, the callback is accessed with the parameters provided by the assistant itself. The assistant does not know which URL it is calling, as it remains invisible to both the assistant and the user.</p>
<h3 id="choosing-the-function-name">Choosing the function name</h3>
<p>The function name should be simple and deterministic about what the function does. Avoid hard-to-guess names or names that do not reflect the function's role, as the assistant may get confused and not call the function when appropriate.</p>
<p>As an example, let's think of a function that queries a user in an external database. The following names are good examples to consider for the call:</p>
<ul>
<li><code>search_user</code></li>
<li><code>query_user</code></li>
</ul>
<p>Bad names include:</p>
<ul>
<li><code>search</code> (too generic)</li>
<li><code>query-user-in-database-data</code> (name too long)</li>
<li><code>pesquisa-usuario</code> (name not in English)</li>
<li><code>search user</code> (name with improper characters)</li>
</ul>
<p>Having the function name, we can think about the function description.</p>
<h3 id="choosing-the-function-description">Choosing the function description</h3>
<p>The function description should conceptually explain two situations: what it does and when it should be called by the assistant. This description should include the scenarios the assistant should consider calling it and when it should not be called, providing a few one‑shot call examples and/or making the function rules explicit.</p>
<h2 id="defining-protocol-functions">Defining protocol functions</h2>
<p>These functions are defined in the <a href="/entities/ai-gateway.md">AI‑gateway</a>, which enables the creation of intelligent agents that perform actions without human intervention. They follow a simple syntax, expecting the function name, a description of what it does, and the invocation parameters.</p>
<p>Protocol functions are defined in the AI gateway using JSON:</p>
<div class="request-item post">
    <span>POST</span>
    <span>
        /api/v1/ai-gateways
    </span>
</div>
<pre><code class="lang-json">{
    &quot;name&quot;: &quot;my-ai-gateway&quot;,
    &quot;parameters&quot;: {
        ...
        &quot;protocolFunctions&quot;: [
            {
                &quot;name&quot;: &quot;list_clients&quot;,
                &quot;description&quot;: &quot;Use this tool to list and search for the user's clients.&quot;,
                &quot;callbackUrl&quot;: &quot;https://my-external-api.com/api/scp/users&quot;,
                &quot;contentFormat&quot;: null
            },
            {
                &quot;name&quot;: &quot;view_client&quot;,
                &quot;description&quot;: &quot;Use this tool to get details and orders of a client by its ID.&quot;,
                &quot;callbackUrl&quot;: &quot;https://my-external-api.com/api/scp/users&quot;,
                &quot;contentFormat&quot;: {
                    &quot;type&quot;: &quot;object&quot;,
                    &quot;properties&quot;: {
                        &quot;user_id&quot;: {
                            &quot;type&quot;: &quot;string&quot;,
                            &quot;format&quot;: &quot;uuid&quot;
                        }
                    },
                    &quot;required&quot;: [&quot;user_id&quot;]
                }
            }
        ]
    }
}
</code></pre>
<p>In the snippet above, you are providing two functions for your AI model: <code>list_clients</code> and <code>view_client</code>, which the model will decide which to execute during its reasoning. You can also provide a JSON content format that the model will use when calling your API with the supplied content.</p>
<p>You can also define the list of supported functions via an endpoint. Every time the model receives a message, it will query the provided endpoint to obtain a list of functions it can execute.</p>
<img src="/assets/diagrams/protocol-functions-2.drawio.svg">
<p>Define the function‑listing endpoints in your AI gateway:</p>
<div class="request-item post">
    <span>POST</span>
    <span>
        /api/v1/ai-gateways
    </span>
</div>
<pre><code class="lang-json">{
    &quot;name&quot;: &quot;my-ai-gateway&quot;,
    &quot;parameters&quot;: {
        ...
        &quot;protocolFunctionSources&quot;: [
            &quot;https://my-external-api.com/api/scp/listings&quot;
        ]
    }
}
</code></pre>
<p>The function‑provision endpoint must respond using the following format:</p>
<div class="request-item post">
    <span>GET</span>
    <span>
        https://my-external-api.com/api/scp/listings
    </span>
</div>
<pre><code class="lang-json">{
    &quot;functions&quot;: [
        {
            &quot;name&quot;: &quot;list_clients&quot;,
            &quot;description&quot;: &quot;Use this tool to list and search for the user's clients.&quot;,
            &quot;callbackUrl&quot;: &quot;https://my-external-api.com/api/scp/users&quot;,
            &quot;contentFormat&quot;: null
        },
        {
            &quot;name&quot;: &quot;view_client&quot;,
            &quot;description&quot;: &quot;Use this tool to get details and orders of a client by its ID.&quot;,
            &quot;callbackUrl&quot;: &quot;https://my-external-api.com/api/scp/users&quot;,
            &quot;contentFormat&quot;: {
                &quot;type&quot;: &quot;object&quot;,
                &quot;properties&quot;: {
                    &quot;user_id&quot;: {
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;format&quot;: &quot;uuid&quot;
                    }
                },
                &quot;required&quot;: [&quot;user_id&quot;]
            }
        }
    ]
}
</code></pre>
<p>These functions are cached for 10 minutes before a new request is made to the supplied endpoint.</p>
<h3 id="handling-function-calls">Handling function calls</h3>
<p>Functions are invoked at the <code>callbackUrl</code> endpoint via an HTTP POST request, with the body:</p>
<pre><code class="lang-json">{
    &quot;function&quot;: {
        &quot;name&quot;: &quot;view_client&quot;,
        &quot;content&quot;: {
            &quot;user_id&quot;: &quot;3e5a2823-98fa-49a1-831a-0c4c5d33450e&quot;
        }
    },
    &quot;context&quot;: {
        &quot;externalUserId&quot;: &quot;...&quot;,
        &quot;moment&quot;: &quot;2025-05-18T03:36:27&quot;
    }
}
</code></pre>
<p>The response to this action must always return an HTTP OK status (2xx or 3xx), even for errors the assistant may have made. A non‑OK response will indicate to the assistant that the function could not be called, and it will not continue with what it was planning to do.</p>
<h4 id="response-format">Response format</h4>
<p>Successful responses should be textual and will be attached as the function's response exactly as returned by the endpoint. There is no JSON format or structure required for this response, but it is advisable to provide a simple, human‑readable answer so the assistant can read the result of the action.</p>
<p>Errors can be common, such as not finding a client by ID or a field not being in the desired format. In these cases, respond with an OK status and include a human‑readable description of the error and how the assistant can work around it in the response body.</p>
<p><strong>It is guaranteed</strong> that the request will strictly follow the JSON Schema of the content defined by the function definition. Functions that do not expect arguments should not specify a content format for that function.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>The more functions you define, the more input tokens you will consume during the reasoning process. The function definition, as well as its format, consumes tokens in the reasoning process.</p>
</div>
<h4 id="authentication">Authentication</h4>
<p>Request authentication is performed via the <code>X-Aivax-Nonce</code> header sent with all protocol function requests, including listing requests.</p>
<p>See the <a href="/docs/en/authentication">authentication</a> manual to understand how to authenticate reverse requests from AIVAX.</p>
<h4 id="user-authentication">User authentication</h4>
<p>Function calls send a <code>$.context.externalUserId</code> field containing the user tag created in a <a href="/docs/en/entities/chat-clients">chat session</a>. This tag can be used to authenticate the user who invoked the function.</p>
<h4 id="security-considerations">Security considerations</h4>
<p>For the AI model, only the name, description, and format of the function are visible. It cannot see the endpoint to which the function points. Additionally, it does not have access to the user tag authenticated in a <a href="/docs/en/entities/chat-clients">chat client</a>.</p>
<h2 id="specialist-functions">Specialist functions</h2>
<p>In addition to the <a href="/docs/en/builtin-tools">built‑in tools</a>, you can define specialist functions that perform specific tasks in your AIVAX account.</p>
<p>You define specialist functions using the <code>aivax://</code> URL scheme, as shown in the example below:</p>
<pre><code class="lang-json">{
    &quot;name&quot;: &quot;my-ai-gateway&quot;,
    &quot;parameters&quot;: {
        ...
        &quot;protocolFunctions&quot;: [
            {
                &quot;name&quot;: &quot;search_disease&quot;,
                &quot;description&quot;: &quot;Use this tool to search for diseases, treatments, and symptoms.&quot;,
                &quot;callbackUrl&quot;: &quot;aivax://query-collection?collection-id=0196f5ef-9334-742b-a988-f913bb3be5ba&amp;top=5&amp;min=0.4&quot;,
                &quot;contentFormat&quot;: {
                    &quot;type&quot;: &quot;object&quot;,
                    &quot;properties&quot;: {
                        &quot;query&quot;: {
                            &quot;type&quot;: &quot;string&quot;,
                            &quot;description&quot;: &quot;Name of the disease, treatment, or symptoms.&quot;
                        }
                    },
                    &quot;required&quot;: [
                        &quot;query&quot;
                    ]
                }
            }
        ]
    }
}
</code></pre>
<p>The function above creates a tool for the AI to query a specific <a href="/docs/en/entities/collections">document collection</a>, guiding the assistant on what to search for in that collection and what to expect in a response. This way, you can link multiple RAG collections so an assistant can retrieve specialist content.</p>
<p>You can customize the description of the JSON Schema properties for specialist functions but not their structure, as our backend expects a specific format to call the functions. Specialist function parameters are supplied in the URL via query parameters.</p>
<p>Currently, only one specialist function exists:</p>
<ul>
<li><p><code>query-collection</code>: performs a RAG search on a specified collection.
Query parameters:</p>
<ul>
<li><code>collection-id</code>: the UUID of the collection to be searched.</li>
<li><code>top</code>: a number indicating how many documents should be returned in the search.</li>
<li><code>min</code>: a decimal indicating the minimum similarity score for the search.</li>
</ul>
<p>JSON format of the function:</p>
<pre><code class="lang-json">{
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;query&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Search content.&quot;
        }
    },
    &quot;required&quot;: [
        &quot;query&quot;
    ]
}
</code></pre>
</li>
</ul>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/CypherPotato/open-indexer-docs/blob/master/docs/en/protocol-functions.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>