<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Serverless Functions | AIVAX </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Serverless Functions | AIVAX ">


        <link rel="icon" href="../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../public/docfx.min.css">
        <link rel="stylesheet" href="../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">
        
        <link href="https://cdn.jsdelivr.net/npm/remixicon@4.6.0/fonts/remixicon.css" rel="stylesheet">

        <meta name="docfx:navrel" content="../../toc.html">
        <meta name="docfx:tocrel" content="toc.html">

        <meta name="docfx:rel" content="../../">


        <meta name="docfx:docurl" content="https://github.com/CypherPotato/open-indexer-docs/blob/master/docs/en/serverless.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
                
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((en)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../index.html">
                        <img id="logo" class="svg" src="../../assets/img/aivax.png" alt="AIVAX">
                        AIVAX
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/en/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="serverless-functions">Serverless Functions</h1>

<p>AIVAX provides serverless functions in JavaScript to perform agentic operations using the AIVAX server, without the need for server hosting or code.</p>
<p>With this tool, you can host JavaScript code that receives a request and responds according to your source code.</p>
<h2 id="api">API</h2>
<p>The available API of AIVAX serverless provides some custom tools and classes:</p>
<ul>
<li><code>console</code>
<ul>
<li><code>log(...args)</code> to write to the debug console.</li>
<li><code>error(...args)</code> to write an error to the debug console.</li>
<li><code>warn(...args)</code> to write a warning to the debug console.</li>
<li><code>info(...args)</code> to write an info to the debug console.</li>
<li><code>table(data, columns)</code> to write a table to the debug console.</li>
</ul>
</li>
<li><code>fetch(url, options) -&gt; Promise&lt;Response&gt;</code>
<ul>
<li><code>options.body</code> can be a <code>string</code>, a <code>FormData</code>, or null.</li>
<li><code>options.method</code> a string representing the HTTP method.</li>
<li><code>options.headers</code> an object containing the request's HTTP headers.</li>
<li><code>options.timeout</code> an integer representing the request timeout.</li>
<li><code>options.redirect</code> a string that can be <code>follow</code> or <code>manual</code>.</li>
<li>The response is an object:</li>
<li><code>async Response.text()</code> returns a <code>Promise&lt;string&gt;</code> with the content.</li>
<li><code>async Response.json()</code> returns a <code>Promise&lt;object&gt;</code> with the JSON content.</li>
<li><code>Response.ok</code> a boolean indicating whether the response is successful.</li>
<li><code>Response.status</code> an integer containing the response status code.</li>
<li><code>Response.statusText</code> a string containing the response status reason. May be null.</li>
<li><code>Response.headers</code> an object containing the response headers.</li>
<li><code>Response.url</code> the URL of the request that produced this response.</li>
</ul>
</li>
</ul>
<p>Serverless request reading methods:</p>
<ul>
<li><code>req.headers</code> returns an object containing the current request's headers.</li>
<li><code>req.query</code> returns an object containing the request's query parameters.</li>
<li><code>req.cookies</code> returns an object containing the cookies set in the request.</li>
<li><code>req.path</code> reads the path (without the query string) of the request.</li>
<li><code>req.fullPath</code> reads the path (with the query string) of the request.</li>
<li><code>req.url</code> reads the full URL of the request, containing the full request path (authority, path, and query).</li>
<li><code>req.method</code> reads the request method.</li>
<li><code>req.json()</code> reads the request body as a JSON value.</li>
<li><code>req.text()</code> reads the request body as text.</li>
<li><code>req.blob()</code> reads the request body as an ArrayBuffer.</li>
<li><code>req.form()</code> reads the request body as form-data.</li>
<li><code>req.multipartForm()</code> reads the request body as multipart form-data.</li>
</ul>
<p>And writing methods for the serverless response:</p>
<ul>
<li><code>res.status(status)</code> sets the numeric status of the response.</li>
<li><code>res.header(name, value)</code> adds a header to the response.</li>
<li><code>res.text(t)</code> sets the response body as text.</li>
<li><code>res.json(t)</code> sets the response body as JSON.</li>
<li><code>res.error(message, status)</code> returns a JSON error in the response with the given status and immediately terminates script execution.</li>
</ul>
<p>And special agentic methods:</p>
<ul>
<li><code>async ai.complete(model, prompt, options)</code> completes the text provided in prompt. Prompt can be a string or an array of messages. The model can be a model provided by AIVAX or a Slug or ID of an AI gateway in your account. Options include properties passed to the chat/completions route, e.g., <code>temperature</code> or <code>tools</code>. The response is the JSON from AIVAX inference response.</li>
<li><code>async ai.completeText(model, prompt, options)</code> works the same as the method above, but instead of returning a JSON with inference response objects, it returns only the text generated by the assistant.</li>
<li><code>async api.get(path)</code> makes an authenticated GET request to an AIVAX endpoint.</li>
<li><code>async api.post(path, body)</code> makes an authenticated POST request with a JSON body to an AIVAX endpoint.</li>
<li><code>async api.put(path, body)</code> makes an authenticated PUT request with a JSON body to an AIVAX endpoint.</li>
<li><code>async api.patch(path, body)</code> makes an authenticated PATCH request with a JSON body to an AIVAX endpoint.</li>
<li><code>async api.delete(path)</code> makes an authenticated DELETE request to an AIVAX endpoint.</li>
</ul>
<p>And some special middleware functions:</p>
<ul>
<li><code>async authenticate()</code> authenticates the request with an API key from your account.</li>
<li><code>sleep(ms)</code> waits the specified time in milliseconds before continuing, limited to 3 minutes.</li>
<li><code>rate_limit(threshold, seconds)</code> applies a rate limiter at the function and request IP level based on the specified threshold and duration in seconds.</li>
</ul>
<h2 id="example">Example</h2>
<p>The example below illustrates an almost complete code that receives a request, authenticates it, runs a function for it, and returns the result.</p>
<blockquote>
<p>[!IMPORTANT] Attention: no serverless function has authentication by default. Authenticate your functions by creating custom logic for this or using the asynchronous <code>authenticate()</code> method.</p>
</blockquote>
<pre><code class="lang-js">async function main() {

    // if not authenticated with a valid API key,
    // exit the function
    if (!await authenticate()) {
        res.status(403);
        return;
    }

    // apply rate limiter on the request to avoid overload
    const RATE_LIMIT_THRESHOLD = 10;
    const RATE_LIMIT_SECONDS = 60;
    rate_limit(RATE_LIMIT_THRESHOLD, RATE_LIMIT_SECONDS);

    // validate that the request is GET
    if (req.method != 'GET') {
        res.status(405);
        return;
    }
    
    // get the query parameter 'q'
    var cityName = req.query[&quot;q&quot;] || res.error(&quot;'q' is required&quot;);

    // perform inference to obtain weather data for the specified city
    const weather = await api.post(&quot;/api/v1/functions/json&quot;, {
        modelName: &quot;@x-ai/grok-4-fast&quot;,
        prompt: &quot;Search for weather data for the specified city.&quot;,
        responseSchema: {
            type: &quot;object&quot;,
            properties: {
                temperature: {
                    type: &quot;number&quot;,
                    description: &quot;The temperature in Celsius of the specified location&quot;
                },
                forecast: {
                    type: &quot;string&quot;,
                    enum: [&quot;rainy&quot;, &quot;thunder&quot;, &quot;clear&quot;],
                    description: &quot;The weather forecast for the specified location&quot;
                }
            },
            required: [&quot;temperature&quot;, &quot;forecast&quot;]
        },
        inputData: {
            cityName
        }
    });

    // return the JSON in the response
    const {
        result
    } = weather.json.data;
    res.json(result);
}
</code></pre>
<p>The code below is simpler: it authenticates the request with one of your API keys, receives the request's JSON body, and returns the function's response:</p>
<pre><code class="lang-js">async function main() {

    if (!await authenticate()) {
        res.status(403);
        return;
    }

    const functionResult = await api.post('/api/v1/functions/json', {
        modelName: &quot;@metaai/llama-4-scout-17b-16e&quot;,
        instructions: &quot;Summarize the text provided by the user.&quot;,
        inputData: req.json(),
        responseSchema: {
            type: &quot;object&quot;,
            properties: {
                summarizedText: {
                    type: &quot;string&quot;
                }
            }
        }
    });

    res.json(functionResult.json.data.result);
}
</code></pre>
<h2 id="limitations">Limitations</h2>
<p>These functions run in an isolated JavaScript container with certain limitations. These limitations are:</p>
<ul>
<li>Maximum memory usage is limited to 32 MB.</li>
<li>The execution time of each script is limited to 5 minutes.</li>
<li>The maximum Regex evaluation time is 10 seconds.</li>
<li>The maximum response size read by Fetch calls is 10 MB (except for calls via AIVAX).</li>
</ul>
<h2 id="pricing">Pricing</h2>
<p>Serverless pricing is charged per execution hour. Each execution accumulates a number of milliseconds. This timing accounts only for the script's execution time and not its compilation, so if your script takes 20 seconds to run, 20,000 milliseconds will be counted. The minimum billed execution time is 20 milliseconds.</p>
<p>The serverless processing cost is <strong>$1/hour</strong>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>All accounts have <strong>10 minutes</strong> free every day. If you exceed this limit, you will start being charged for processing. If your account has a negative balance, the function's processing will be cancelled.</p>
</div>
<h2 id="rate-limits">Rate Limits</h2>
<p>The rate limits for serverless functions are described in the <a href="/docs/en/limits">rate limits</a>.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/CypherPotato/open-indexer-docs/blob/master/docs/en/serverless.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>