# Serverless Functions

AIVAX provides serverless functions in JavaScript to perform agentic operations using the AIVAX server, without the need for server hosting or code.

With this tool, you can host JavaScript code that receives a request and responds according to your source code.

## API

The available API of AIVAX serverless provides some custom tools and classes:

- `console`
    - `log(...args)` to write to the debug console.
    - `error(...args)` to write an error to the debug console.
    - `warn(...args)` to write a warning to the debug console.
    - `info(...args)` to write an info to the debug console.
    - `table(data, columns)` to write a table to the debug console.
- `fetch(url, options) -> Promise<Response>`
    - `options.body` can be a `string`, a `FormData`, or null.
    - `options.method` a string representing the HTTP method.
    - `options.headers` an object containing the request's HTTP headers.
    - `options.timeout` an integer representing the request timeout.
    - `options.redirect` a string that can be `follow` or `manual`.
    - The response is an object:
    - `async Response.text()` returns a `Promise<string>` with the content.
    - `async Response.json()` returns a `Promise<object>` with the JSON content.
    - `Response.ok` a boolean indicating whether the response is successful.
    - `Response.status` an integer containing the response status code.
    - `Response.statusText` a string containing the response status reason. May be null.
    - `Response.headers` an object containing the response headers.
    - `Response.url` the URL of the request that produced this response.

Serverless request reading methods:

- `req.headers` returns an object containing the current request's headers.
- `req.query` returns an object containing the request's query parameters.
- `req.cookies` returns an object containing the cookies set in the request.
- `req.path` reads the path (without the query string) of the request.
- `req.fullPath` reads the path (with the query string) of the request.
- `req.url` reads the full URL of the request, containing the full request path (authority, path, and query).
- `req.method` reads the request method.
- `req.json()` reads the request body as a JSON value.
- `req.text()` reads the request body as text.
- `req.blob()` reads the request body as an ArrayBuffer.
- `req.form()` reads the request body as form-data.
- `req.multipartForm()` reads the request body as multipart form-data.

And writing methods for the serverless response:

- `res.status(status)` sets the numeric status of the response.
- `res.header(name, value)` adds a header to the response.
- `res.text(t)` sets the response body as text.
- `res.json(t)` sets the response body as JSON.
- `res.error(message, status)` returns a JSON error in the response with the given status and immediately terminates script execution.

And special agentic methods:

- `async ai.complete(model, prompt, options)` completes the text provided in prompt. Prompt can be a string or an array of messages. The model can be a model provided by AIVAX or a Slug or ID of an AI gateway in your account. Options include properties passed to the chat/completions route, e.g., `temperature` or `tools`. The response is the JSON from AIVAX inference response.
- `async ai.completeText(model, prompt, options)` works the same as the method above, but instead of returning a JSON with inference response objects, it returns only the text generated by the assistant.
- `async api.get(path)` makes an authenticated GET request to an AIVAX endpoint.
- `async api.post(path, body)` makes an authenticated POST request with a JSON body to an AIVAX endpoint.
- `async api.put(path, body)` makes an authenticated PUT request with a JSON body to an AIVAX endpoint.
- `async api.patch(path, body)` makes an authenticated PATCH request with a JSON body to an AIVAX endpoint.
- `async api.delete(path)` makes an authenticated DELETE request to an AIVAX endpoint.

And some special middleware functions:

- `async authenticate()` authenticates the request with an API key from your account.
- `sleep(ms)` waits the specified time in milliseconds before continuing, limited to 3 minutes.
- `rate_limit(threshold, seconds)` applies a rate limiter at the function and request IP level based on the specified threshold and duration in seconds.

## Example

The example below illustrates an almost complete code that receives a request, authenticates it, runs a function for it, and returns the result.

> [!IMPORTANT] Attention: no serverless function has authentication by default. Authenticate your functions by creating custom logic for this or using the asynchronous `authenticate()` method.

```js
async function main() {

    // if not authenticated with a valid API key,
    // exit the function
    if (!await authenticate()) {
        res.status(403);
        return;
    }

    // apply rate limiter on the request to avoid overload
    const RATE_LIMIT_THRESHOLD = 10;
    const RATE_LIMIT_SECONDS = 60;
    rate_limit(RATE_LIMIT_THRESHOLD, RATE_LIMIT_SECONDS);

    // validate that the request is GET
    if (req.method != 'GET') {
        res.status(405);
        return;
    }
    
    // get the query parameter 'q'
    var cityName = req.query["q"] || res.error("'q' is required");

    // perform inference to obtain weather data for the specified city
    const weather = await api.post("/api/v1/functions/json", {
        modelName: "@x-ai/grok-4-fast",
        prompt: "Search for weather data for the specified city.",
        responseSchema: {
            type: "object",
            properties: {
                temperature: {
                    type: "number",
                    description: "The temperature in Celsius of the specified location"
                },
                forecast: {
                    type: "string",
                    enum: ["rainy", "thunder", "clear"],
                    description: "The weather forecast for the specified location"
                }
            },
            required: ["temperature", "forecast"]
        },
        inputData: {
            cityName
        }
    });

    // return the JSON in the response
    const {
        result
    } = weather.json.data;
    res.json(result);
}
```

The code below is simpler: it authenticates the request with one of your API keys, receives the request's JSON body, and returns the function's response:

```js
async function main() {

    if (!await authenticate()) {
        res.status(403);
        return;
    }

    const functionResult = await api.post('/api/v1/functions/json', {
        modelName: "@metaai/llama-4-scout-17b-16e",
        instructions: "Summarize the text provided by the user.",
        inputData: req.json(),
        responseSchema: {
            type: "object",
            properties: {
                summarizedText: {
                    type: "string"
                }
            }
        }
    });

    res.json(functionResult.json.data.result);
}
```

## Limitations

These functions run in an isolated JavaScript container with certain limitations. These limitations are:

- Maximum memory usage is limited to 32 MB.
- The execution time of each script is limited to 5 minutes.
- The maximum Regex evaluation time is 10 seconds.
- The maximum response size read by Fetch calls is 10 MB (except for calls via AIVAX).

## Pricing

Serverless pricing is charged per execution hour. Each execution accumulates a number of milliseconds. This timing accounts only for the script's execution time and not its compilation, so if your script takes 20 seconds to run, 20,000 milliseconds will be counted. The minimum billed execution time is 20 milliseconds.

The serverless processing cost is **$1/hour**.

> [!NOTE]
> All accounts have **10 minutes** free every day. If you exceed this limit, you will start being charged for processing. If your account has a negative balance, the function's processing will be cancelled.

## Rate Limits

The rate limits for serverless functions are described in the [rate limits](/docs/en/limits).